# Представяне на свързан списък като шаблонен клас

Линеен свързан списък представлява структура от данни, състояща се от клетки от следния вид:
```cpp
struct Node 
{
    T Value;
    Node *Link;
};
```
 където едното поле представлява стойност от тип `T`, а другата, указател към следващата, по ред, клетка. Списъкът е редица от динамично-заделени обекти от тип `Node`, като всеки от обектите поддържа връзка към следващия, чрез полето `Link`. Същото поле, в последния, по ред, обект сочи към стойност `nullptr`.
 Реализирайте шаблон на клас на свързан списък със следния интерфейс:
 ```cpp
template <typename T>
class LinkedList {
    
    public:
    
        // Канонична четворка (необходима е, защото ще заделяме клетките динамично):
        LinkedList() = default;
        ~LinkedList();
        LinkedList( const LinkedList & );
        LinkedList & operator=( const LinkedList & );
        
        // Задава полето current да сочи първия елемент на списъка:
        void ResetCurrent() { current = front; }

        // Връща истина, ако полето current сочи последния елемент в списъка:
        bool IsCurrentAtTheBack() { return current->Link == nullptr; }

        // Премества полето current с positions на брой позиции напред в списъка
        // (помислете, как да подходите, ако указателят достигне последния елемент):
        void IterateCurrent( unsigned positions = 1 );

        // Въвежда нов елемент на позиция след текущия. 
        // Трябва да укажете на текущия да сочи към новия си наследник, 
        // както и на ново-създадения да сочи към стария директен наследник на текущия:
        void InsertAfterCurrent( const T &newElement );

        // Въвежда нов елемент в началото на списъка:
        void PushUpFront( const T &newFrontElement );

        // Изтрива първия елемент на списъка. 
        // Трябва да укажете на полето 'front' да сочи директния наследник на стария първи елемент:
        void DeleteFront();
        
        // Селектори за извличане съответно на стойността 
        // на текущия и първия елемент на списъка, както и на размера на списъка:
        T GetCurrent() const;
        T GetFront() const;
        size_t GetSize() const;
    
    private:
    
        // Указател към първия елемент в списъка:
        Node *front = nullptr;

        // Указател към текущия елемент на списъка 
        // (използва се при итериране на елементите на списъка):
        Node *current = nullptr;

        // Брой на елементите на списъка:
        size_t size = 0;
    
        struct Node 
        {
            T Value;
            Node *Link;
        };
};
 ```
