# Лекция: Вход и изход. Потокове и Работа с файлове в C++

В тази лекция ще разгледаме основните концепции за вход и изход в C++ чрез използването на потокове, както и работата с файлове – текстови и двоични. Ще разгледаме също основните класове от стандартната библиотека, предназначени за файлови операции. Кодът в примерите е на английски език, за да се запази международната конвенция.

---

## 1. Потоци в C++

Потоците представляват основния механизъм за обмен на данни между програмата и външния свят (конзола, файлове и др.). Те абстрахират четенето и записването на данни.

### 1.1 Стандартни потоци

- **`std::cin`** – използва се за въвеждане от клавиатурата.
- **`std::cout`** – използва се за извеждане на стандартния изход (обикновено екрана).
- **`std::cerr`** – използва се за извеждане на съобщения за грешки.
- **`std::clog`** – използва се за логване на съобщения.

### 1.2 Основни операции

#### Извеждане с оператора `<<`

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

#### Въвеждане с оператора `>>`
```cpp
#include <iostream>

int main() {
    int number;

    std::cout << "Enter a number: ";
    std::cin >> number;

    std::cout << "You entered: " << number << std::endl;

    return 0;
}
```

### 1.3 Манипулатори на потоци
Манипулаторите са специални функции, които променят форматирането на входа и изхода.

 Примери:

- `std::endl` – вмъква нов ред и изпразва буфера.
- `std::setw` (от `<iomanip>`) – задава ширина на изходното поле.

#### Пример с `std::endl`

```cpp
#include <iostream>

int main() {
    std::cout << "First line" << std::endl;
    std::cout << "Second line" << std::endl;
    std::cout << "Third line" << std::endl;
    return 0;
}
```

Примерен изход:

```
First line
Second line
Third line
```
#### Каква е разликата между `\n` и `std::endl`

- `\n` е символ за нов ред, който просто премества курсора на нов ред.
- `std::endl` също премества курсора на нов ред, но освен това изпразва буфера на изходния поток, което може да бъде полезно за незабавното извеждане на съобщения.

#### Пример с `std::setw`

```cpp
#include <iostream>
#include <iomanip>

int main() {
    std::cout << std::setw(10) << "Hello" << std::setw(10) << "World" << std::endl;
    return 0;
}
```

Примерен изход:

```
     Hello     World
```

## 2. Работа с файлове

За работа с файлове в C++ се използват класове от заглавния файл `<fstream>`. Тези класове позволяват както четене, така и записване във файлове.

### 2.1 Основни класове

- `std::ifstream` – входен поток за четене от файл.
- `std::ofstream` – изходен поток за запис във файл.
- `std::fstream` – поток, който може да се използва и за четене, и за запис.

### 2.2 Работа с текстови файлове

#### Пример: Запис във текстов файл

```cpp
#include <fstream>
#include <iostream>

int main() {
    std::ofstream outFile("example.txt"); // Open file for writing
    if (!outFile) {
        std::cerr << "Error opening file for writing!" << std::endl;
        return 1;
    }

    outFile << "This is a sample text written to the file." << std::endl;

    outFile.close(); // Close the file to free resources

    return 0;
}
```

#### Пример: Четене от текстов файл

```cpp
#include <fstream>
#include <iostream>
#include <string>

int main() {
    std::ifstream inFile("example.txt"); // Open file for reading

    if (!inFile) {
        std::cerr << "Error opening file for reading!" << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(inFile, line)) {
        std::cout << line << std::endl;
    }

    inFile.close(); // Close the file
    return 0;
}
```

### 2.3 Работа с двоични файлове
Двоичните файлове се използват за съхранение на данни във формат, който не е текстов. При тях данните се четат и записват като байтове.

#### Пример: Запис във двоичен файл
```cpp
#include <fstream>
#include <iostream>

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    std::ofstream outFile("data.bin", std::ios::binary); // Open binary file for writing

    if (!outFile) {
        std::cerr << "Error opening binary file for writing!" << std::endl;
        return 1;
    }

    // write an array
    outFile.write(reinterpret_cast<char*>(numbers), sizeof(numbers));

    // write a single number
    outFile.write((char*)&numbers[0], sizeof(numbers[0]));

    outFile.close();
    return 0;
}
```

#### Пример: Четене от двоичен файл

```cpp
#include <fstream>
#include <iostream>

int main() {
    int numbers[5];
    std::ifstream inFile("data.bin", std::ios::binary); // Open binary file for reading

    if (!inFile) {
        std::cerr << "Error opening binary file for reading!" << std::endl;
        return 1;
    }

    inFile.read(reinterpret_cast<char*>(numbers), sizeof(numbers));
    inFile.close();

    for (int i = 0; i < 5; ++i) {
        std::cout << "Number " << i + 1 << ": " << numbers[i] << std::endl;
    }

    return 0;
}
```

### 2.4 Флагове при работа с файлове

При отваряне на файлове можем да използваме различни флагове, които променят поведението на файловите потоци. Някои от най-често използваните флагове са:

- `std::ios::in` – отваря файла за четене.
- `std::ios::out` – отваря файла за запис.
- `std::ios::binary` – отваря файла в двоичен режим.
- `std::ios::app` – отваря файла в режим на добавяне (append), т.е. записът се извършва в края на файла.
- `std::ios::ate` – отваря файла и поставя курсора в края, но позволява запис и четене.
- `std::ios::trunc` – ако файлът съществува, неговото съдържание се изтрива при отваряне за запис.

Флаговете могат да се комбинират чрез използването на оператора | (битово "или"). Например:

```cpp
std::ofstream outFile("example.txt", std::ios::out | std::ios::trunc);
```

В горния пример файлът се отваря за запис и, ако вече съществува, съдържанието му се изтрива.

#### Флагове по подразбиране при fstream:

- **ifstream**: По подразбиране използва флага `std::ios::in`, което означава, че файлът се отваря за четене.
- **ofstream**: По подразбиране използва флаговете `std::ios::out | std::ios::trunc`, т.е. файлът се отваря за запис и, ако вече съществува, съдържанието му се изтрива.
- **fstream**: По подразбиране използва флаговете `std::ios::in | std::ios::out`, което позволява и четене, и запис върху файла.

### 2.5 Полезни методи при работа с файлове

При работа с файлове чрез обектите от класовете `ifstream`, `ofstream` и `fstream`, стандартната библиотека предоставя редица полезни методи, които ви помагат да контролирате състоянието на файловия поток и позиционирането в него. Ето някои от тях:

- **open()**  
  Използва се за отваряне на файл, ако не сте посочили файла директно при създаване на обекта.  
  ```cpp
  std::ifstream inFile;
  inFile.open("example.txt");
  ```
- ***is_open()***
  Връща true, ако файлът е отворен успешно. Това ви позволява да проверите дали операцията по отваряне е преминала успешно.
  ```cpp
  if (!inFile.is_open()) {
      std::cerr << "Failed to open the file." << std::endl;
  }
  ```
- **close()**
  Затваря файла и освобождава свързаните ресурси. Важно е винаги да затваряте отворените файлове след приключване на операциите с тях.
  ```cpp
  inFile.close();
  ```
- **good()**
  Връща true, ако файловият поток не е в състояние на грешка. Може да се използва за проверка на целостта на потока по време на операции.
  ```cpp
  if (inFile.good()) {
      // Потокът е в добро състояние.
  }
  ```
- **fail()**
  Връща true, ако последната операция с потока е довела до грешка (например, неуспешно четене или писане).
  ```cpp
  if (inFile.fail()) {
      std::cerr << "An error occurred during the file operation." << std::endl;
  }
  ```
- **eof()**
  Връща true, ако е достигнат крайът на файла. Използва се често в цикли при четене на файл, за да се определи кога да се прекрати четенето.
  ```cpp
  while (!inFile.eof()) {
      // Четене на файла
  }
  ```
- **tellg() и tellp()**
  
  tellg() – Връща текущата позиция в потока за четене (get pointer).

  tellp() – Връща текущата позиция в потока за писане (put pointer).

  Тези методи са полезни, когато трябва да знаете или да манипулирате текущата позиция в потока.
  ```cpp
  std::streampos pos = inFile.tellg();
  ```
- **seekg() и seekp()**

  seekg() – Използва се за преместване на позицията за четене към определена позиция в потока.

  seekp() – Използва се за преместване на позицията за писане.

  Тези методи ви позволяват да навигирате произволно в съдържанието на файла.
  ```cpp
  inFile.seekg(0, std::ios::beg);  // Придвижва указателя за четене в началото на файла
  ```

Използването на тези методи прави работата с файлове по-гъвкава и позволява по-добра обработка на грешки и управление на позиционирането в потока.

## 3. Добри практики при работа с потоци и файлове
- Проверка при отваряне: Винаги проверявайте дали файлът е отворен успешно, преди да започнете операции с него.
- Затваряне на файловете: След приключване на операциите, затваряйте файловете, за да освободите системни ресурси.
- Използване на RAII: Използвайте локални обекти за файлови потоци, така че затварянето на файловете да става автоматично при излизане от обхвата.
- Обработка на грешки: Редовно проверявайте за възникнали грешки по време на четене и запис.
- Правилно кодиране: При работа с двоични файлове, обръщайте внимание на правилното кодиране и декодиране на данните.

## Заключение
В тази лекция разгледахме:

- Основните принципи на вход и изход в C++ чрез потоци.
- Стандартните потоци за конзолата: `std::cin`, `std::cout`, `std::cerr` и `std::clog`.
- Работа с текстови и двоични файлове чрез класовете `std::ifstream`, `std::ofstream` и `std::fstream`.
