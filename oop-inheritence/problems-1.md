# Задачи по Обектно-ориентирано програмиране с C++

## Задача 1: Система за управление на библиотека

**Цел**: Разработете проста система за управление на библиотека, демонстрираща наследяване и достъп до наследени компоненти.

**Изисквания**:

1. Създайте базов клас `LibraryItem` със следните характеристики:

   * private член-данни: `title` (заглавие), `id` (инвентарен номер)
   * protected член-данни: `available` (булева стойност за наличност), `checkoutCount` (брой заемания)
   * public методи: конструктор, деструктор, getter и setter за title, метод `displayInfo()`, метод `checkOut()`, метод `returnItem()`
2. Създайте два производни класа:

   - `Book`: наследява `LibraryItem` и добавя член-данни `author`
   - `Magazine`: наследява `LibraryItem` и добавя член-данна `issueNumber`
3. Добавете различна логика за заемане в различните класове:

   * В `Book`: override-нете метода `checkOut()`, който освен да променя `available`, също увеличава `checkoutCount` и отпечатва колко пъти книгата е заемана досега
   * В `Magazine`: override-нете метода `checkOut()` с проверка, че списания с номер над 50 не могат да се заемат (ценни колекционерски броеве
   * Предефинирайте метода `displayInfo()` във всеки производен клас. В предефинирания метод, извикайте версията от базовия клас и добавете допълнителна информация

**Подсказки**:

- Използвайте подходящ модификатор за наследяване (public)
- В производните класове извиквайте версията на `displayInfo()` от базовия клас
- Добавете съобщения в конструкторите и деструкторите, за да наблюдавате реда на извикване
- Спомнете си как се получава достъп до protected членове в наследниците

## Задача 2: Йерархия на геометрични фигури

**Цел** : Създайте йерархия на геометрични фигури, демонстрираща множествено наследяване и диамантния проблем.

**Изисквания** :

1. Създайте базов клас `Shape` с:
   * protected член-данна `name` (име на фигурата)
   * public конструктор и виртуален деструктор
   * виртуален метод `display()`
2. Създайте два междинни класа:
   * `TwoDShape`: наследява виртуално `Shape`, добавя чисто виртуален метод `calculateArea()`
   * `ColoredShape`: наследява виртуално `Shape`, добавя член-данна `color` и метод `getColor()`
3. Създайте производен клас `Circle`, който наследява и `TwoDShape`, и `ColoredShape`, и добавя:
   * член-данна `radius` (радиус)
   * имплементация на метода `calculateArea()`

**Подсказки** :

* Използвайте ключовата дума `virtual` при наследяване за решаване на диамантния проблем
* Обърнете внимание как конструкторът на `Circle` трябва да извика конструктора на `Shape` само веднъж
* Демонстрирайте какво би се случило без виртуално наследяване
* Добавете съобщения във всички конструктори и деструктори, за да видите реда на извикване

## Задача 3: Система за електронни устройства

**Цел**: Създайте система за управление на устройства, демонстрираща upcast/downcast и dynamic_cast.

**Изисквания**:

1. Създайте базов клас `Device` с:
   - protected член-данни: `name` и `isOn`
   - public виртуални методи: `turnOn()`, `turnOff()`, `displayInfo()`
2. Създайте два производни класа:
   - `Phone`: добавя метод `makeCall(std::string number)`
   - `Computer`: добавя метод `runProgram(std::string program)`
3. Напишете функция `useDevice(Device* device)`, която:
   - Приема указател към базов клас
   - Използва dynamic_cast за определяне на реалния тип на обекта
   - В зависимост от типа, извиква специфичен метод

**Подсказки**:

- Използвайте `dynamic_cast` за безопасно преобразуване между типовете
- Винаги проверявайте резултата от dynamic_cast за nullptr
- За да работи dynamic_cast, базовият клас трябва да има поне един виртуален метод
- Демонстрирайте разликата между upcast (безопасно) и downcast (изисква проверка)

**Общи напътствия за трите задачи**:

1. **За конструкторите и деструкторите**:
   - Добавяйте съобщения във всеки конструктор и деструктор
   - Помнете, че конструкторите се извикват от базовия към производния клас
   - Деструкторите се извикват в обратен ред - от производния към базовия клас
2. **За видимостта**:
   - private членове не са достъпни в производните класове
   - protected членове са достъпни в производните класове, но не и извън тях
   - public членове са достъпни навсякъде
3. **За virtual методите**:
   - Виртуалните методи позволяват полиморфизъм
   - Чисто виртуалните методи правят класа абстрактен
   - Виртуални деструктори са важни за правилно освобождаване на паметта
4. **За dynamic_cast**:
   - Работи само с полиморфни класове (с виртуални методи)
   - Връща nullptr ако преобразуването е невъзможно
   - Полезен е за проверка на реалния тип на обект

Не се колебайте да експериментирате с кода и да наблюдавате поведението при различни ситуации!
