# Задачи по Обектно-ориентирано програмиране с C++ (наследяване)

## Задача 1: Ред на изпълнение на каноничната четворка

Изпълнете следната програма и се опитайте да си обясните изхода от нея. Следете внимателно реда на изпълнение на функциите.

```cpp
#include <iostream>

class Base {

    public:
        Base();
        Base(const Base& other);
        ~Base();
        Base& operator=(const Base& other);
};

class Derived : public Base {

    public:
        Derived();
        Derived(const Derived& other);
        ~Derived();
        Derived& operator=(const Derived& other);
};

Base::Base() {

    std::cout << "Base()\n";
}

Base::~Base() {

    std::cout << "~Base()\n";
}

Base::Base(const Base& other) {

    std::cout << "Base() - Copy\n";
}

Base & Base::operator=(const Base& other) {

    std::cout << "Base() - operator=\n";
    return *this;
}

Derived::Derived() : Base() {

    std::cout << "Derived()\n";
}

Derived::~Derived() {

    std::cout << "~Derived()\n";
}

Derived::Derived(const Derived& other): Base() {

    std::cout << "Derived() - Copy\n";
}

Derived& Derived::operator=(const Derived& other) {

    std::cout << "Derived() - operator=\n";
    if (this != &other) Base::operator=(other);
    return *this;
}

int main() {

    Base base1;
    Base base2 = base1;
    Base base3;
    base3 = base2;

    std::cout << "-----------------------------------\n";

    Derived derived1;
    Derived derived2 = derived1;
    Derived derived3;
    derived3 = derived2;

    std::cout << "------------------------------------\n";

    Derived derived4;
    Base base4 = dynamic_cast<Base &>(derived4);

    return 0;
}
```

## Задача 2: Система за управление на библиотека

**Цел**: Разработете проста система за управление на библиотека, демонстрираща наследяване и достъп до наследени компоненти.

**Изисквания**:

1. Създайте базов клас `LibraryItem` със следните характеристики:

   * private член-данни: `title` (заглавие), `id` (инвентарен номер)
   * protected член-данни: `available` (булева стойност за наличност), `checkoutCount` (брой заемания)
   * public методи: конструктор, деструктор, getter и setter за title, метод `displayInfo()`, метод `checkOut()`, метод `returnItem()`
2. Създайте два производни класа:

   - `Book`: наследява `LibraryItem` и добавя член-данни `author`
   - `Magazine`: наследява `LibraryItem` и добавя член-данна `issueNumber`
3. Добавете различна логика за заемане в различните класове:

   * В `Book`: override-нете метода `checkOut()`, който освен да променя `available`, също увеличава `checkoutCount` и отпечатва колко пъти книгата е заемана досега
   * В `Magazine`: override-нете метода `checkOut()` с проверка, че списания с номер над 50 не могат да се заемат (ценни колекционерски броеве
   * Предефинирайте метода `displayInfo()` във всеки производен клас. В предефинирания метод, извикайте версията от базовия клас и добавете допълнителна информация

**Подсказки**:

- Използвайте подходящ модификатор за наследяване (public)
- В производните класове извиквайте версията на `displayInfo()` от базовия клас
- Добавете съобщения в конструкторите и деструкторите, за да наблюдавате реда на извикване
- Спомнете си как се получава достъп до protected членове в наследниците

## Задача 3 (повишена трудност): Нива и подходящ вид на наследяване

1. Реализирайте следния клас, представляващ триъгълник. Хвърлете подходящо изключение в конструктора и в мутаторите (setter-ите), в случай, че е подадена невалидна стойност за страна на триъгълника (стойността е неположително и/или не е спазено правилото на триъгълника):

```cpp
class Triangle {

    public:

        Triangle( double, double double );

        void SetSideA( double );
        void SetSideB( double );
        void SetSideC( double );

        double GetSideA() const;
        double GetSideB() const;
        double GetSideC() const;

        double GetPerimeter() const;

    private:

        // Потенциална помощна функция за валидиране на правилото на триъгълника:
        bool doNotFormValidTriangle( double side1, double side2, double side3 );

        double sideA, sideB, sideC;
};
```

2. Реализирайте следния клас, представляващ равнобедрен триъгълник, който нследява предходния. Помислете как правилно да го реализирате, включително какъв вид наследяване да приложите:

```cpp
class TriangleIsosceles : /* (помислете за вида наследяване) */ Triangle {
    
    public:

        // Конструктор, който приема като аргументи съответно дължините на бедрата и на основата:
        TriangleIsosceles( double legLength, double baseLength );

        void SetLegLength( double );
        void SetBaseLength( double );

        double GetLegLength() const;
        double GetBaseLength() const;

        double GetPerimeter() const;
};
```

3. Реализирайте следния клас, представляващ равностранен триъгълник, който наследява равнобедрения. Отново помислете как правилно да го реализирате, включително какъв вид наследяване да приложите:

```cpp
class TriangleEquilateral : /* (помислете за вида наследяване) */ TriangleIsosceles  {

    public:

        // Конструктор, който приема като аргумент дължината на страната на тригълника:
        TriangleEquilateral( double side );

        void SetSide( double );

        double GetSide() const;

        double GetPerimeter() const;
};
```

4. Реализирайте фунцкия `void PrintTriangle( const Triangle &triangle )`, която извежда страните и обиколката на триъгълника.

5. Модифицирайте горната фунцкия, така че да изежда конкретна информация, в случай, че триъгълника се окаже обикновен, равнобедрен, или равностранен. За целта проверете дали аргумента може да се преобразува до някой от дъщерните класове на базовия `Triangle` (за целта използвайте `dynamica_cast`).

П.П. (не бе част от първоначалния вариант на условието, за което се извинявам) - за да реализирате успешно точка 5, помислете какво още трябва да се добави към реализацията на базовия клас Triangle?

## Задача 4: Йерархия на геометрични фигури

**Цел** : Създайте йерархия на геометрични фигури, демонстрираща множествено наследяване и диамантния проблем.

**Изисквания** :

1. Създайте базов клас `Shape` с:
   * protected член-данна `name` (име на фигурата)
   * public конструктор и виртуален деструктор
   * виртуален метод `display()`
2. Създайте два междинни класа:
   * `TwoDShape`: наследява виртуално `Shape`, добавя чисто виртуален метод `calculateArea()`
   * `ColoredShape`: наследява виртуално `Shape`, добавя член-данна `color` и метод `getColor()`
3. Създайте производен клас `Circle`, който наследява и `TwoDShape`, и `ColoredShape`, и добавя:
   * член-данна `radius` (радиус)
   * имплементация на метода `calculateArea()`

**Подсказки** :

* Използвайте ключовата дума `virtual` при наследяване за решаване на диамантния проблем
* Обърнете внимание как конструкторът на `Circle` трябва да извика конструктора на `Shape` само веднъж
* Демонстрирайте какво би се случило без виртуално наследяване
* Добавете съобщения във всички конструктори и деструктори, за да видите реда на извикване

## Задача 5: Система за електронни устройства

**Цел**: Създайте система за управление на устройства, демонстрираща upcast/downcast и dynamic_cast.

**Изисквания**:

1. Създайте базов клас `Device` с:
   - protected член-данни: `name` и `isOn`
   - public виртуални методи: `turnOn()`, `turnOff()`, `displayInfo()`
2. Създайте два производни класа:
   - `Phone`: добавя метод `makeCall(std::string number)`
   - `Computer`: добавя метод `runProgram(std::string program)`
3. Напишете функция `useDevice(Device* device)`, която:
   - Приема указател към базов клас
   - Използва dynamic_cast за определяне на реалния тип на обекта
   - В зависимост от типа, извиква специфичен метод

**Подсказки**:

- Използвайте `dynamic_cast` за безопасно преобразуване между типовете
- Винаги проверявайте резултата от dynamic_cast за nullptr
- За да работи dynamic_cast, базовият клас трябва да има поне един виртуален метод
- Демонстрирайте разликата между upcast (безопасно) и downcast (изисква проверка)

**Общи напътствия за трите задачи (2-ра, 4-та и 5-та)**:

1. **За конструкторите и деструкторите**:
   - Добавяйте съобщения във всеки конструктор и деструктор
   - Помнете, че конструкторите се извикват от базовия към производния клас
   - Деструкторите се извикват в обратен ред - от производния към базовия клас
2. **За видимостта**:
   - private членове не са достъпни в производните класове
   - protected членове са достъпни в производните класове, но не и извън тях
   - public членове са достъпни навсякъде
3. **За virtual методите**:
   - Виртуалните методи позволяват полиморфизъм
   - Чисто виртуалните методи правят класа абстрактен
   - Виртуални деструктори са важни за правилно освобождаване на паметта
4. **За dynamic_cast**:
   - Работи само с полиморфни класове (с виртуални методи)
   - Връща nullptr ако преобразуването е невъзможно
   - Полезен е за проверка на реалния тип на обект

Не се колебайте да експериментирате с кода и да наблюдавате поведението при различни ситуации!

## Задача 6: Животни (абстрактни класове):

1. Реализирайте следния абстрактен клас:

```cpp
class Animal {

    public:

        // Канонична четворка:
        Animal( const char *name, unsigned age );
        Animal( const Animal &other );
        // Помислете защо е необходим абстарктния деструктор?
        virtual ~Animal();
        Animal & operator=( const Animal &other );

        void SetName( const char * name );
        void SetAge( unsigned age );

        const char * GetName() const;
        unsigned GetAge() const;

        // Член-функция за извеждане на всички полета на животното:
        virtual void PrintInformation() const = 0;
        // Член фунцкия, която извежда съобщение за ръмженето, което издава съответното животно:
        virtual void PrintRoar() const = 0;

    private:
        char *name = nullptr;
        unsigned age = 0;
};
```

2. Създайте класовете `Dog`, `Cat`, `Eagle`, всеки, от които наследява абстркатния клас `Animal`. Добавете допълнителните полета `favoriteToyName` от тип `char *` за класа `Dog`, `isAggressive` от тип `bool` за класа `Cat` и `wingSpan` от тип `double` за класа `Eagle`. Не забравяйте да реализирате всички виртуални член-функции от базовия клас `Animal`. 
